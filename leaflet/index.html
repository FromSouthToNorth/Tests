<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>leaflet</title>
  <link rel="stylesheet" href="/css/reset.css">
  <script src="./src/leaflet/tutf.js"></script>
  <link rel="stylesheet" href="src/css/leaflet.css"/>
  <script src="./src/leaflet/leaflet.js"></script>
  <script src="./src/leaflet/leaflet-geosearch.js"></script>
  <link rel="stylesheet" href="src/css/leaflet-geosearch.css">
  <!--    <script src="https://unpkg.com/geojson-vt@3.2.0/geojson-vt.js"></script>-->
  <!--    <script src="./src/leaflet/geojson-vt.js"></script>-->

  <script src="src/leaflet/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="./src/css/MarkerCluster.Default.css">

  <link rel="stylesheet" href="src/css/leaflet-geoman.css"/>
  <script src="./src/leaflet/leaflet-geoman.js"></script>

  <script src="./src/uuid/uuid.js"></script>

  <script src="./src/leaflet/leaflet.textpath.js"></script>

  <script src="../d3/src/d3.js"></script>

  <script src="../utils/keybinding.js"></script>
  <script src="../utils/hotkeys.js"></script>
  <script src="../utils/detect.js"></script>
  <script src="../utils/cmd.js"></script>
  <script src="src/leaflet/L.Control.Layers.Minimap.js"></script>
  <link rel="stylesheet" href="src/css/control.layers.minimap.css">
  <script src="src/leaflet/Control.MiniMap.js"></script>
  <link rel="stylesheet" href="src/css/Control.MiniMap.css">
  <style>
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: #000;
    }

    .leaflet-popup-content p {
      font-size: 10px;
    }

    #info {
      position: fixed;
      z-index: 999;
      bottom: 5px;
      left: 120px;
      padding: 10px;
      border: none;
      border-radius: 3px;
      font-size: 12px;
      text-align: center;
      color: #222;
      background: rgba(255, 255, 255, 0.6);
    }

    .leaflet-popup-content div {
      word-wrap: break-word;
    }

    .leaflet-popup-content div p {
      margin: 2px;
    }

    .leaflet-popup-content div p span {
      padding-left: 24px;
    }

    .arrow-icon {
      width: 14px;
      height: 14px;
    }

    .arrow-icon > div {
      margin-left: -1px;
      margin-top: -3px;
      transform-origin: center center;
      font: 12px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif;
    }

    /* edit-menu */
    .edit-menu {
      position: absolute;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: vertical;
      -webkit-box-direction: normal;
      -ms-flex-direction: column;
      flex-direction: column;
      background: #fff;
      border-radius: 4px;
    }

    button {
      text-align: center;
      border: 0;
      background: #fff;
      color: #333;
      font-size: 12px;
      display: inline-block;
      border-radius: 4px;
      cursor: pointer;
    }

    .edit-menu-item {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      border-radius: 0;
      padding: 0 12px;
    }

    button.disabled {
      background-color: rgba(255, 255, 255, .25);
      color: rgba(0, 0, 0, .4);
      cursor: not-allowed;
    }

    #map .leaflet-control-scale-line {
      color: #000;
      font-weight: bold;
    }
  </style>
</head>
<body>
<div id="map"></div>
<pre id="info"></pre>
<script src="src/data/geoJSONStyle.js"></script>
<script>
  const map = L.map('map', {
    zoom: 12,
    minZoom: 3,
    maxZoom: 18,
    center: [30.3339, 106.9303],
  });
  const positronLabels = L.tileLayer(`https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}`)
    .addTo(map);

  const positionAssistOverlay = L.tileLayer(`https://api.mapbox.com/styles/v1/openstreetmap/ckasmteyi1tda1ipfis6wqhuq/tiles/256/{z}/{x}/{y}?access_token={access_token}`, {
    access_token: 'pk.eyJ1Ijoib3BlbnN0cmVldG1hcCIsImEiOiJjbGRlaXd3cHUwYXN3M29waWp0bGNnYWdyIn0.RRlhUnKlUFNhKsKjhaZ2zA',
  })
    .addTo(map);
  const pao = L.tileLayer(`https://api.mapbox.com/styles/v1/openstreetmap/ckasmteyi1tda1ipfis6wqhuq/tiles/256/{z}/{x}/{y}?access_token={access_token}`, {
    access_token: 'pk.eyJ1Ijoib3BlbnN0cmVldG1hcCIsImEiOiJjbGRlaXd3cHUwYXN3M29waWp0bGNnYWdyIn0.RRlhUnKlUFNhKsKjhaZ2zA',
  });

  const colorMapOfChina = L.tileLayer(`https://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}?blankTile=false`);
  const miniMap = new L.Control.MiniMap(colorMapOfChina).addTo(map);

  L.control.scale()
    .addTo(map);

  map.on('click', (e) => {
    L.DomEvent.stopPropagation(e);
    const { containerPoint, latlng } = e;
    const point = turf.point([latlng.lng, latlng.lat]);
    const options = { precision: 7, coordinates: 2 };
    const truncated = turf.truncate(point, options);
    drawLayers.forEach(e => {
      if (e.pm.enabled()) {
        e.pm.disable();
      }
    });
    editMenu()
      .close();
    document.getElementById('info').innerHTML =
      `<span>x: ${containerPoint.x} y: ${containerPoint.y}</span> <br/> <br/><span>${truncated.geometry.coordinates[1]}, ${truncated.geometry.coordinates[0]}</span>`;
  });

  bindContextMenu('Map', map);

  map.on('move', () => {
    editMenu()
      .close();
  });

  const linShuiMarker = L.marker([30.3339, 106.9303])
    .on('click', e => {
      L.DomEvent.stopPropagation(e);
      selectLayer = e.sourceTarget;
    })
    .bindPopup(`<p>邻水</p>`)
    .addTo(map);
  linShuiMarker.shape = 'marker';
  bindContextMenu('marker', linShuiMarker);
  linShuiMarker.uuid = uuid.v4();

  const layerGroup = L.layerGroup()
    .addTo(map);

  /*****  Leaflet-Geoman  *****/

  map.pm.setLang('zh');
  const drawLayers = [];
  const drawShadowLayers = [];
  // add Leaflet-Geoman controls with some options to the map
  map.pm.addControls({
    position: 'topleft',
    drawCircle: false,
  });

  map.pm.setGlobalOptions({
    limitMarkersToCount: 20,
  });

  let _menu = d3.select(null);

  function editMenu(context) {
    const selection = d3.select('#map');

    const editMenu = function() {
      const { operations, event } = context;
      if (!operations.length) return;

      const { containerPoint, sourceTarget } = event;

      let _menuHeight;
      let _menuWidth = 44;
      const buttonHeight = 24;
      // 稍微偏离目标位置的菜单
      const _menuSideMargin = 26;
      const _vpBottomMargin = 12; // viewport bottom margin
      const _verticalPadding = 4;

      _menuHeight = _verticalPadding * 2 + operations.length * buttonHeight;

      _menu = selection.append('dev')
        .attr('class', 'edit-menu')
        .style('padding', _verticalPadding + 'px 0');

      const buttons = _menu.selectAll('.edit-menu-item')
        .data(operations);

      const buttonsEnter = buttons.enter()
        .append('button')
        .attr('class', 'edit-menu-item')
        .style('height', buttonHeight + 'px')
        .text(function(d) {
          return d.title;
        })
        .on('click', click);

      buttonsEnter.merge(buttons)
        .classed('disabled', function(d) {
          return d.disabled();
        });

      updatePosition();

      function click(d3_event, e) {
        d3_event.stopPropagation();
        if (!e.disabled()) {
          e.operation({
            event: d3_event,
            sourceTarget,
          });
        }
        editMenu.close();
      }

      function updatePosition() {
        if (!_menu || _menu.empty()) return;
        const viewport = selection.node()
          .getBoundingClientRect();

        if (containerPoint.x < 0 ||
          containerPoint.x > viewport.width ||
          containerPoint.y < 0 ||
          containerPoint.y > viewport.height) {

          editMenu.close();
          return;
        }
        const offset = [0, 0];

        const menuLeft = displayOnLeft(viewport);
        offset[0] = menuLeft ? -1 * (_menuSideMargin + _menuWidth) : _menuSideMargin;

        const menuBottom = displayOnBottom(viewport);
        offset[1] = menuBottom ? -containerPoint.y - _menuHeight + viewport.height - _vpBottomMargin : 0;

        const origin = [containerPoint.x + offset[0], containerPoint.y + offset[1]];

        _menu.style('left', origin[0] + 'px')
          .style('top', origin[1] - 16 + 'px')
          .style('z-index', 999);
      }

      function displayOnLeft(viewport) {
        return (containerPoint.x + _menuSideMargin + _menuWidth) > viewport.width;
      }

      function displayOnBottom(viewport) {
        return (containerPoint.y + _menuHeight > (viewport.height + _vpBottomMargin));
      }
    };


    editMenu.close = function() {
      _menu.remove();
    };

    return editMenu;
  }

  function getOperations(key) {
    const operationMap = new Map();
    const markerOperations = [
      {
        title: '移动',
        operation: move,
        disabled: () => {
          return false;
        },
      },
      {
        title: '复制',
        operation: copy,
        disabled: () => {
          return false;
        },
      },
      {
        title: '删除',
        operation: remove,
        disabled: () => {
          return false;
        },
      },
    ];
    operationMap.set('marker', markerOperations);
    operationMap.set('circleMarker', markerOperations);
    const lineOperations = [
      {
        title: '移动',
        operation: move,
        disabled: () => {
          return false;
        },
      },
      {
        title: '编辑',
        operation: edit,
        disabled: () => {
          return false;
        },
      },
      {
        title: '复制',
        operation: copy,
        disabled: () => {
          return false;
        },
      },
      {
        title: '截取',
        operation: segmentation,
        disabled: () => {
          return false;
        },
      },
      {
        title: '删除',
        operation: remove,
        disabled: () => {
          return false;
        },
      },
    ];
    operationMap.set('polyline', lineOperations);
    const polygonOperations = [
      {
        title: '移动',
        operation: move,
        disabled: () => {
          return false;
        },
      },
      {
        title: '编辑',
        operation: edit,
        disabled: () => {
          return false;
        },
      },
      {
        title: '复制',
        operation: copy,
        disabled: () => {
          return false;
        },
      },
      {
        title: '删除',
        operation: remove,
        disabled: () => {
          return false;
        },
      },
    ];
    operationMap.set('polygon', polygonOperations);
    const mapOperations = [
      {
        title: '当前位置',
        operation: location,
        disabled: () => {
          return false;
        },
      },
      {
        title: '粘贴',
        operation: copyLayer,
        disabled: () => {
          return setCopyLayer.size === 0;
        },
      },
    ];
    operationMap.set('Map', mapOperations);

    function location(d3_event) {
      console.log(d3_event);
      const { clientX, clientY } = d3_event.event;
      console.log(clientX, clientY);
      const loc = map.layerPointToLatLng(L.point(clientX, clientY));
      alert(JSON.stringify(loc));
    }


    /** 编辑 */
    function edit(d3_event) {
      const { sourceTarget } = d3_event;
      sourceTarget.pm.enable({
        allowSelfIntersection: false,
      });
    }

    function move(d3_event) {
      const { sourceTarget } = d3_event;
      console.log(drawLayers);
      if (sourceTarget) {
        sourceTarget.pm.enableLayerDrag();
        sourceTarget.on('pm:dragstart', e => {
          console.log('pm:dragstart: ', e);
        });
        sourceTarget.on('pm:drag', e => {
          console.log(e);
        });
        sourceTarget.on('pm:dragend', e => {
          const { sourceTarget } = e;
          sourceTarget.pm.disableLayerDrag();
          sourceTarget.off('pm:dragend');
          sourceTarget.off('pm:drag');
        });
      }
    }

    function copy(d3_event) {
      selectLayer = d3_event.sourceTarget;
      setCopyLayer.add(selectLayer);
      origLatLng = selectLayer.getLatLng ? selectLayer.getLatLng() : selectLayer.getCenter();
    }

    function remove(d3_event) {
      const { sourceTarget } = d3_event;
      if (sourceTarget && map.hasLayer(sourceTarget)) {
        map.removeLayer(sourceTarget);
      }
    }

    /** 裁剪方法 */
    function segmentation(d3_event) {
      isSegmentation = true;
      relatedLayer = d3_event.sourceTarget;
      map.pm.enableDraw('Marker', {});
    }

    return operationMap.get(key);
  }


  /** 绑定右键菜单 */
  function bindContextMenu(shape, layer) {
    layer.on('contextmenu', e => {
      L.DomEvent.stopPropagation(e);
      const context = {
        event: e,
        operations: getOperations(shape),
      };
      const menu = editMenu(context);
      menu.close();
      menu();
    });
  }

  let isSegmentation = false;

  let relatedLayer;

  /** 计算距离点最近的线 */
  function pointToLineDistance(pt) {
    const minMap = [];
    drawLayers.forEach(layer => {
      const geoJSON = layer.toGeoJSON();
      const distance = turf.pointToLineDistance(pt, geoJSON, { units: 'kilometers' });
      minMap.push({
        layer,
        distance,
      });
    });
    let min = Infinity, res;
    minMap.forEach(e => {
      if (e.distance < min) {
        min = e.distance;
        res = e.layer;
      }
    });
    return res;
  }

  /** 计算点是否在线上 */
  function booleanPointOnLine(pt) {
    for (const drawLayer of drawLayers) {
      const geoJSON = drawLayer.toGeoJSON();
      console.log(turf.booleanPointOnLine(pt, geoJSON));
    }
  }

  function segmentationLine(layer) {
    const pt = layer.toGeoJSON();
    const geoJSON = relatedLayer.toGeoJSON();
    if (turf.booleanWithin(pt, geoJSON)) {
      const split = turf.lineSplit(geoJSON, pt);
      const { features } = split;
      for (let i = 0; i < features.length; i++) {
        const line = L.GeoJSON.geometryToLayer(features[i], {});
        bindContextMenu('polyline', line);
        line.uuid = uuid.v4();
        drawLayers.push(line);
        line.shape = 'polyline';
        line
          .on('mouseover', function(e) {
            e.sourceTarget.setStyle({
              weight: 8,
              opacity: 0.6,
              color: '#f6634f',
            });
          })
          .on('mouseout', function(e) {
            e.sourceTarget.setStyle({
              weight: 3,
              opacity: 1,
              color: '#3388ff',
            });
          })
          .addTo(map);
      }
      const index = drawLayersFindIndex(relatedLayer.uuid);
      if (index !== -1) {
        map.removeLayer(relatedLayer);
        drawLayers.splice(index, 1);
      }
    }
    else {
      alert('请将截取点放在线内的点上');
    }
    map.removeLayer(layer);
    map.pm.disableDraw();
    relatedLayer = undefined;
    isSegmentation = !isSegmentation;
  }

  function drawLayersFindIndex(uuid) {
    let layer;
    layerGroup.eachLayer(e => {
      if (e.uuid === uuid) {
        layer = e;
      }
    });
    if (layer) {
      layerGroup.removeLayer(layer);
    }
    return drawLayers.findIndex(e => {
      return e.uuid === uuid;
    });
  }

  map.on('pm:vertexadded', e => {
    console.log(e);
  });

  // 监听绘制开始
  // map.on('pm:drawstart', e => {
  //   console.log('pm:drawstart: ', e);
  //   const { workingLayer } = e;
  //   // 监听绘制定点
  //   workingLayer.on('pm:vertexadded', e => {
  //     drawLayers.forEach(layer => {
  //       const geoJSON = layer.toGeoJSON(7);
  //       geoJSON.properties.id = layer.uuid;
  //       console.log(geoJSON);
  //     });
  //     console.log('pm:vertexadded: ', e);
  //   });
  // });

  let selectLayer;
  const setCopyLayer = new Set();
  map.on('mousemove', mapMousemove);

  const key = {
    '⌘+C': () => {
      if (!selectLayer) return;
      setCopyLayer.add(selectLayer);
      origLatLng = selectLayer.getLatLng ? selectLayer.getLatLng() : selectLayer.getCenter();
    },
    '⌘+V': () => {
      copyLayer();
    },
    '⌘+Z': () => {
      const popLayer = drawLayers.pop();
      if (popLayer && map.hasLayer(popLayer)) {
        map.removeLayer(popLayer);
      }
      if (copyMarker && map.hasLayer(copyMarker)) {
        map.removeLayer(copyMarker);
      }
    },
    'Esc': () => {
      if (copyMarker && map.hasLayer(copyMarker)) {
        map.removeLayer(copyMarker);
      }
      map.pm.disableDraw();
    },
  };

  const keys = {}, keyboards = [];
  Object.keys(key)
    .forEach(e => {
      let keyboard = [uiCmd(e)];
      keyboards.push(keyboard);
      Object.assign(keys, { [keyboard]: key[e] });
    });

  hotkeys(keyboards.join(','), function(event, handler) {
      keys[handler.key]();
    },
  );

  let copyMarker;
  let origLatLng;
  let isCopyLayer = true;

  function copyLayer() {
    isCopyLayer = false;
    const layers = [...setCopyLayer];
    if (!layers.length) return;
    const layer = layers[setCopyLayer.size - 1];
    const { options, shape } = layer;
    copyMarker = L[shape](mousemoveLatlng, options)
      .addTo(map);
    copyMarker.shape = shape;
    copyMarker.uuid = uuid.v4();
    drawLayers.push(copyMarker);
    d3.select(document)
      .on('click', copyLayerMapClick);

    function copyLayerMapClick() {
      bindContextMenu(copyMarker.shape, copyMarker);
      copyMarker = undefined;
      isCopyLayer = true;
      d3.select(document)
        .on('click', null);
    }
  }

  let mousemoveLatlng;

  function mapMousemove(e) {
    mapMousemoveLatLng(e);
  }

  function mapMousemoveLatLng(event) {
    if (!copyMarker && !selectLayer || !origLatLng) return;
    const { latlng } = event;
    const { shape } = copyMarker || selectLayer;
    const currMove = map.latLngToLayerPoint(latlng);
    const origMove = map.latLngToLayerPoint(origLatLng);
    const delta = [currMove.x - origMove.x, currMove.y - origMove.y];
    if (shape === 'marker' || shape === 'circleMarker') {
      const end = [origMove.x + delta[0], origMove.y + delta[1]];
      mousemoveLatlng = map.layerPointToLatLng(L.point(end[0], end[1]));
      if (copyMarker && map.hasLayer(copyMarker)) {
        copyMarker.setLatLng(mousemoveLatlng);
      }
    }
    else {
      mousemoveLatlng = [];
      const latLngs = selectLayer.getLatLngs();
      for (let i = 0; i < latLngs.length; i++) {
        if (Array.isArray(latLngs[i])) {
          mousemoveLatlng.push([]);
          let lls = [];
          for (let j = 0; j < latLngs[i].length; j++) {
            const start = map.latLngToLayerPoint(latLngs[i][j]);
            const end = [start.x + delta[0], start.y + delta[1]];
            const endLatLng = map.layerPointToLatLng(L.point(end[0], end[1]));
            lls.push(endLatLng);
          }
          mousemoveLatlng[i] = lls;
        }
        else {
          const start = map.latLngToLayerPoint(latLngs[i]);
          const end = [start.x + delta[0], start.y + delta[1]];
          const endLatLng = map.layerPointToLatLng(L.point(end[0], end[1]));
          mousemoveLatlng.push(endLatLng);
        }
      }
      if (copyMarker && map.hasLayer(copyMarker)) {
        copyMarker.setLatLngs(mousemoveLatlng);
      }
    }
  }

  const polygon = [
    'Rectangle', 'Polygon',
  ];

  const marker = [
    'Text',
    'Marker',
  ];

  const polyline = [
    'Line',
  ];

  const circleMarker = [
    'CircleMarker',
  ];

  map.on('pm:create', (e) => {
    map.on('contextmenu', disableDraw);

    function disableDraw() {
      map.pm.disableDraw();
      map.off('contextmenu', disableDraw);
    }

    let { layer, shape } = e;
    if (!isSegmentation) {
      console.log('create one', shape, e);
      if (polygon.includes(shape)) {
        shape = 'polygon';
        layer.setStyle({
          color: '#4CAF50',
        });
      }
      if (marker.includes(shape)) {
        shape = 'marker';
      }
      if (polyline.includes(shape)) {
        shape = 'polyline';
        layer
          .on('mouseover', function(e) {
            e.sourceTarget.setStyle({
              weight: 8,
              opacity: 0.6,
              color: '#f6634f',
            });
          })
          .on('mouseout', function(e) {
            e.sourceTarget.setStyle({
              weight: 3,
              opacity: 1,
              color: '#3388ff',
            });
          });
      }
      if (circleMarker.includes(shape)) {
        shape = 'circleMarker';
      }
      layer.shape = shape;
      layer.isSegmentation = isSegmentation;
      bindContextMenu(shape, layer);
      layer.on('click', e => {
        L.DomEvent.stopPropagation(e);
        selectLayer = e.sourceTarget;
      });
      layer.uuid = uuid.v4();
      layer.bindPopup(`<sapn>${popup(layer)}</sapn>`);
      drawLayers.push(layer);
    }
    else {
      segmentationLine(layer);
    }
  });

  function popup(layer) {
    const res = {};
    res['编号'] = layer.uuid;
    if (layer.shape === 'polygon') {
      res['面积'] = turf.round(turf.area(layer.toGeoJSON()), 2) + '㎡';
    }
    if (layer.shape === 'polyline') {
      res['长度'] = turf.round(turf.length(layer.toGeoJSON(), { units: 'kilometers' }), 3) + '㎞';
    }
    if (layer.shape === 'marker' || layer.shape === 'circleMarker') {
      const latLng = turf.truncate(layer.toGeoJSON());
      res['经度'] = latLng.geometry.coordinates[0];
      res['纬度'] = latLng.geometry.coordinates[1];
    }
    let html = '';
    Object.keys(res)
      .forEach(key => {
        html += `<p>${key}: ${res[key]}</p>`;
      });
    return html;
  }
</script>
</body>
</html>
