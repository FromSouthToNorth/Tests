<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>leaflet</title>
  <link rel="stylesheet" href="/css/reset.css">
  <script src="./src/leaflet/tutf.js"></script>
  <link rel="stylesheet" href="src/css/leaflet.css"/>
  <script src="./src/leaflet/leaflet.js"></script>
  <script src="./src/leaflet/leaflet-geosearch.js"></script>
  <link rel="stylesheet" href="src/css/leaflet-geosearch.css">
  <!--    <script src="https://unpkg.com/geojson-vt@3.2.0/geojson-vt.js"></script>-->
  <!--    <script src="./src/leaflet/geojson-vt.js"></script>-->

  <script src="src/leaflet/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="./src/css/MarkerCluster.Default.css">

  <link rel="stylesheet" href="src/css/leaflet-geoman.css"/>
  <script src="./src/leaflet/leaflet-geoman.js"></script>

  <script src="./src/uuid/uuid.js"></script>

  <script src="./src/leaflet/leaflet.textpath.js"></script>

  <script src="../d3/src/d3.js"></script>

  <script src="../utils/keybinding.js"></script>
  <script src="../utils/hotkeys.js"></script>
  <script src="../utils/detect.js"></script>
  <script src="../utils/cmd.js"></script>

  <style>
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: #555555;
    }

    .leaflet-popup-content p {
      font-size: 10px;
    }

    #info {
      position: fixed;
      z-index: 999;
      bottom: 10px;
      left: 10px;
      padding: 10px;
      border: none;
      border-radius: 3px;
      font-size: 12px;
      text-align: center;
      color: #222;
      background: rgba(255, 255, 255, 0.2);
    }

    .leaflet-popup-content div {
      word-wrap: break-word;
    }

    .leaflet-popup-content div p {
      margin: 2px;
    }

    .leaflet-popup-content div p span {
      padding-left: 24px;
    }

    .arrow-icon {
      width: 14px;
      height: 14px;
    }

    .arrow-icon > div {
      margin-left: -1px;
      margin-top: -3px;
      transform-origin: center center;
      font: 12px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif;
    }

    /* edit-menu */
    .edit-menu {
      position: absolute;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: vertical;
      -webkit-box-direction: normal;
      -ms-flex-direction: column;
      flex-direction: column;
      background: #fff;
      border-radius: 4px;
    }

    button {
      text-align: center;
      border: 0;
      background: #fff;
      color: #333;
      font-size: 12px;
      display: inline-block;
      border-radius: 4px;
      cursor: pointer;
    }

    .edit-menu-item {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      border-radius: 0;
      padding: 0 12px;
    }
  </style>
</head>
<body>
<div id="map"></div>
<pre id="info"></pre>
<script src="src/data/geoJSONStyle.js"></script>
<script>

  delete L.Icon.Default.prototype._getIconUrl;
  L.Icon.Default.mergeOptions({
    iconRetinaUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAMAAAAhFXfZAAAC91BMVEVMaXEzeak2f7I4g7g3g7cua5gzeKg8hJo3grY4g7c3grU0gLI2frE0daAubJc2gbQwd6QzeKk2gLMtd5sxdKIua5g1frA2f7IydaM0e6w2fq41fK01eqo3grgubJgta5cxdKI1f7AydaQydaMxc6EubJgvbJkwcZ4ubZkwcJwubZgubJcydqUydKIxapgubJctbJcubZcubJcvbJYubJcvbZkubJctbJctbZcubJg2f7AubJcrbZcubJcubJcua5g3grY0fq8ubJcubJdEkdEwhsw6i88vhswuhcsuhMtBjMgthMsrg8srgss6is8qgcs8i9A9iMYtg8spgcoogMo7hcMngMonf8olfso4gr8kfck5iM8jfMk4iM8he8k1fro7itAgesk2hs8eecgzfLcofssdeMg0hc4cd8g2hcsxeLQbdsgZdcgxeLImfcszhM0vda4xgckzhM4xg84wf8Yxgs4udKsvfcQucqhUndROmdM1fK0wcZ8vb5w0eqpQm9MzeKhXoNVcpdYydKNWn9VZotVKltJFjsIwcJ1Rms9OlslLmtH///8+kc9epdYzd6dbo9VHkMM2f7FHmNBClM8ydqVcpNY9hro3gLM9hLczealQmcw3fa46f7A8gLMxc6I3eagyc6FIldJMl9JSnNRSntNNl9JPnNJFi75UnM9ZodVKksg8kM45jc09e6ZHltFBk883gbRBh7pDk9EwcaBzn784g7dKkcY2i81Om9M7j85Llc81is09g7Q4grY/j9A0eqxKmdFFltBEjcXf6fFImdBCiLxJl9FGlNFBi78yiMxVndEvbpo6js74+vx+psPP3+o/ks5HkcpGmNCjwdZCkNDM3ehYoNJEls+lxNkxh8xHks0+jdC1zd5Lg6r+/v/H2ufz9/o3jM3t8/edvdM/k89Th61OiLBSjbZklbaTt9BfptdjmL1AicBHj8hGk9FAgK1dkLNTjLRekrdClc/k7fM0icy0y9tgp9c4jc2NtM9Dlc8zicxeXZn3AAAAQ3RSTlMAHDdTb4yPA+LtnEQmC4L2EmHqB7XA0d0sr478x4/Yd5i1zOfyPkf1sLVq4Nh3FvjxopQ2/STNuFzUwFIwxKaejILpIBEV9wAABhVJREFUeF6s1NdyFEcY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',
    iconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=',
    shadowUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC',
  });

  const map = L.map('map', {
    center: [30.3339, 106.9303],
    maxZoom: 18,
    minZoom: 3,
    zoom: 12,
  });
  const positronLabels = L.tileLayer(`https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}`)
    .addTo(map);

  map.on('click', (e) => {
    L.DomEvent.stopPropagation(e);
    const { containerPoint, latlng } = e;
    const point = turf.point([latlng.lng, latlng.lat]);
    const options = { precision: 7, coordinates: 2 };
    const truncated = turf.truncate(point, options);
    editMenu()
      .close();
    document.getElementById('info').innerHTML =
      `<span>x: ${containerPoint.x} y: ${containerPoint.y}</span> <br/> <br/><span>${truncated.geometry.coordinates[1]}, ${truncated.geometry.coordinates[0]}</span>`;
  });

  bindContextMenu('Map', map);

  map.on('move', () => {
    editMenu()
      .close();
  });

  const linShuiMarker = L.marker([30.3339, 106.9303])
    .bindPopup(`<p>邻水</p>`)
    .addTo(map);
  linShuiMarker.shape = 'marker';
  bindContextMenu('marker', linShuiMarker);
  linShuiMarker.uuid = uuid.v4();

  const layerGroup = L.layerGroup()
    .addTo(map);

  /*****  Leaflet-Geoman  *****/

  map.pm.setLang('zh');
  const drawLayers = [];
  const drawShadowLayers = [];
  // add Leaflet-Geoman controls with some options to the map
  map.pm.addControls({
    position: 'topleft',
    drawCircle: false,
  });

  map.pm.setGlobalOptions({
    limitMarkersToCount: 20,
  });

  let _menu = d3.select(null);

  function editMenu(context) {
    const selection = d3.select('#map');

    const editMenu = function() {
      const { operations, event } = context;
      if (!operations.length) return;

      const { containerPoint, sourceTarget } = event;

      let _menuHeight;
      let _menuWidth = 44;
      const buttonHeight = 34;
      // 稍微偏离目标位置的菜单
      const _menuSideMargin = 26;
      const _vpBottomMargin = 12; // viewport bottom margin
      const _verticalPadding = 4;

      _menuHeight = _verticalPadding * 2 + operations.length * buttonHeight;

      _menu = selection.append('dev')
        .attr('class', 'edit-menu')
        .style('padding', _verticalPadding + 'px 0');

      const buttons = _menu.selectAll('.edit-menu-item')
        .data(operations);

      const buttonsEnter = buttons.enter()
        .append('button')
        .attr('class', 'edit-menu-item')
        .style('height', buttonHeight + 'px')
        .text(function(d) {
          return d.title;
        })
        .on('click', click);

      updatePosition();

      function click(d3_event, e) {
        d3_event.stopPropagation();
        e.operation({
          event: d3_event,
          sourceTarget,
        });
        editMenu.close();
      }

      function updatePosition() {
        if (!_menu || _menu.empty()) return;
        const viewport = selection.node()
          .getBoundingClientRect();

        if (containerPoint.x < 0 ||
          containerPoint.x > viewport.width ||
          containerPoint.y < 0 ||
          containerPoint.y > viewport.height) {

          editMenu.close();
          return;
        }
        const offset = [0, 0];

        const menuLeft = displayOnLeft(viewport);
        offset[0] = menuLeft ? -1 * (_menuSideMargin + _menuWidth) : _menuSideMargin;

        const menuBottom = displayOnBottom(viewport);
        offset[1] = menuBottom ? -containerPoint.y - _menuHeight + viewport.height - _vpBottomMargin : 0;

        const origin = [containerPoint.x + offset[0], containerPoint.y + offset[1]];

        _menu.style('left', origin[0] + 'px')
          .style('top', origin[1] - 16 + 'px')
          .style('z-index', 999);
      }

      function displayOnLeft(viewport) {
        return (containerPoint.x + _menuSideMargin + _menuWidth) > viewport.width;
      }

      function displayOnBottom(viewport) {
        return (containerPoint.y + _menuHeight > (viewport.height + _vpBottomMargin));
      }
    };


    editMenu.close = function() {
      _menu.remove();
    };

    return editMenu;
  }

  function getOperations(key) {
    const operationMap = new Map();
    const markerOperations = [
      {
        title: '移动',
        operation: move,
      },
      {
        title: '复制',
        operation: copy,
      },
      {
        title: '删除',
        operation: remove,
      },
    ];
    operationMap.set('marker', markerOperations);
    operationMap.set('circleMarker', markerOperations);
    const lineOperations = [
      {
        title: '移动',
        operation: move,
      },
      {
        title: '编辑',
        operation: edit,
      },
      {
        title: '复制',
        operation: copy,
      },
      {
        title: '截取',
        operation: segmentation,
      },
      {
        title: '删除',
        operation: remove,
      },
    ];
    operationMap.set('polyline', lineOperations);
    const polygonOperations = [
      {
        title: '移动',
        operation: move,
      },
      {
        title: '编辑',
        operation: edit,
      },
      {
        title: '复制',
        operation: copy,
      },
      {
        title: '删除',
        operation: remove,
      },
    ];
    operationMap.set('polygon', polygonOperations);
    const mapOperations = [
      {
        title: '当前位置',
        operation: location,
      },
    ];
    operationMap.set('Map', mapOperations);

    function location(d3_event) {
      console.log(d3_event);
      const { clientX, clientY } = d3_event.event;
      console.log(clientX, clientY);
      const loc = map.layerPointToLatLng(L.point(clientX, clientY));
      alert(JSON.stringify(loc));
    }


    /** 编辑 */
    function edit(d3_event) {
      const { sourceTarget } = d3_event;
      sourceTarget.pm.enable({
        allowSelfIntersection: false,
      });
    }

    function move(d3_event) {
      const { sourceTarget } = d3_event;
      console.log(drawLayers);
      if (sourceTarget) {
        sourceTarget.pm.enableLayerDrag();
        sourceTarget.on('pm:dragstart', e => {
          console.log('pm:dragstart: ', e);
        });
        sourceTarget.on('pm:drag', e => {
          console.log(e);
        });
        sourceTarget.on('pm:dragend', e => {
          const { sourceTarget } = e;
          sourceTarget.pm.disableLayerDrag();
          sourceTarget.off('pm:dragend');
          sourceTarget.off('pm:drag');
        });
      }
    }

    function copy(d3_event) {
      selectLayer = d3_event.sourceTarget;
      setCopyLayer.add(selectLayer);
      origLatLng = selectLayer.getLatLng ? selectLayer.getLatLng() : selectLayer.getCenter();
    }

    function remove(d3_event) {
      const { sourceTarget } = d3_event;
      if (sourceTarget && map.hasLayer(sourceTarget)) {
        map.removeLayer(sourceTarget);
      }
    }

    /** 裁剪方法 */
    function segmentation(d3_event) {
      isSegmentation = true;
      relatedLayer = d3_event.sourceTarget;
      map.pm.enableDraw('Marker', {});
    }

    return operationMap.get(key);
  }


  /** 绑定右键菜单 */
  function bindContextMenu(shape, layer) {
    layer.on('contextmenu', e => {
      L.DomEvent.stopPropagation(e);
      const context = {
        event: e,
        operations: getOperations(shape),
      };
      const menu = editMenu(context);
      menu.close();
      menu();
    });
  }

  let isSegmentation = false;

  let relatedLayer;

  /** 计算距离点最近的线 */
  function pointToLineDistance(pt) {
    const minMap = [];
    drawLayers.forEach(layer => {
      const geoJSON = layer.toGeoJSON();
      const distance = turf.pointToLineDistance(pt, geoJSON, { units: 'kilometers' });
      minMap.push({
        layer,
        distance,
      });
    });
    let min = Infinity, res;
    minMap.forEach(e => {
      if (e.distance < min) {
        min = e.distance;
        res = e.layer;
      }
    });
    return res;
  }

  /** 计算点是否在线上 */
  function booleanPointOnLine(pt) {
    for (const drawLayer of drawLayers) {
      const geoJSON = drawLayer.toGeoJSON();
      console.log(turf.booleanPointOnLine(pt, geoJSON));
    }
  }

  function segmentationLine(layer) {
    const pt = layer.toGeoJSON();
    const geoJSON = relatedLayer.toGeoJSON();
    if (turf.booleanWithin(pt, geoJSON)) {
      const split = turf.lineSplit(geoJSON, pt);
      const { features } = split;
      for (let i = 0; i < features.length; i++) {
        const line = L.GeoJSON.geometryToLayer(features[i], {});
        bindContextMenu('polyline', line);
        line.uuid = uuid.v4();
        drawLayers.push(line);
        line.addTo(map);
      }
      const index = drawLayersFindIndex(relatedLayer.uuid);
      if (index !== -1) {
        map.removeLayer(relatedLayer);
        drawLayers.splice(index, 1);
      }
    }
    else {
      alert('请将截取点放在线内的点上');
    }
    map.removeLayer(layer);
    map.pm.disableDraw();
    relatedLayer = undefined;
    isSegmentation = !isSegmentation;
  }

  function drawLayersFindIndex(uuid) {
    let layer;
    layerGroup.eachLayer(e => {
      if (e.uuid === uuid) {
        layer = e;
      }
    });
    if (layer) {
      layerGroup.removeLayer(layer);
    }
    return drawLayers.findIndex(e => {
      return e.uuid === uuid;
    });
  }

  map.on('pm:vertexadded', e => {
    console.log(e);
  });

  // 监听绘制开始
  // map.on('pm:drawstart', e => {
  //   console.log('pm:drawstart: ', e);
  //   const { workingLayer } = e;
  //   // 监听绘制定点
  //   workingLayer.on('pm:vertexadded', e => {
  //     drawLayers.forEach(layer => {
  //       const geoJSON = layer.toGeoJSON(7);
  //       geoJSON.properties.id = layer.uuid;
  //       console.log(geoJSON);
  //     });
  //     console.log('pm:vertexadded: ', e);
  //   });
  // });

  let selectLayer;
  const setCopyLayer = new Set();
  map.on('mousemove', mapMousemove);

  const key = {
    '⌘+C': () => {
      if (!selectLayer) return;
      setCopyLayer.add(selectLayer);
      origLatLng = selectLayer.getLatLng ? selectLayer.getLatLng() : selectLayer.getCenter();
    },
    '⌘+V': () => {
      copyLayer();
    },
    '⌘+Z': () => {
      const popLayer = drawLayers.pop();
      if (popLayer && map.hasLayer(popLayer)) {
        map.removeLayer(popLayer);
      }
      if (copyMarker && map.hasLayer(copyMarker)) {
        map.removeLayer(copyMarker);
      }
    },
    'Esc': () => {
      if (copyMarker && map.hasLayer(copyMarker)) {
        map.removeLayer(copyMarker);
      }
      map.pm.disableDraw();
    },
  };

  const keys = {}, keyboards = [];
  Object.keys(key)
    .forEach(e => {
      let keyboard = [uiCmd(e)];
      keyboards.push(keyboard);
      Object.assign(keys, { [keyboard]: key[e] });
    });

  hotkeys(keyboards.join(','), function(event, handler) {
      keys[handler.key]();
    },
  );

  let copyMarker;
  let origLatLng;
  let isCopyLayer = true;

  function copyLayer() {
    isCopyLayer = false;
    const layers = [...setCopyLayer];
    if (!layers.length) return;
    const layer = layers[setCopyLayer.size - 1];
    const { options, shape } = layer;
    copyMarker = L[shape](mousemoveLatlng, options)
      .addTo(map);
    copyMarker.shape = shape;
    copyMarker.uuid = uuid.v4();
    drawLayers.push(copyMarker);
    d3.select(document)
      .on('click', copyLayerMapClick);

    function copyLayerMapClick() {
      bindContextMenu(copyMarker.shape, copyMarker);
      copyMarker = undefined;
      isCopyLayer = true;
      d3.select(document)
        .on('click', null);
    }
  }

  let mousemoveLatlng;

  function mapMousemove(e) {
    mapMousemoveLatLng(e);
  }

  function mapMousemoveLatLng(event) {
    if (!copyMarker && !selectLayer || !origLatLng) return;
    const { latlng } = event;
    const { shape } = copyMarker || selectLayer;
    const currMove = map.latLngToLayerPoint(latlng);
    const origMove = map.latLngToLayerPoint(origLatLng);
    const delta = [currMove.x - origMove.x, currMove.y - origMove.y];
    if (shape === 'marker' || shape === 'circleMarker') {
      const end = [origMove.x + delta[0], origMove.y + delta[1]];
      mousemoveLatlng = map.layerPointToLatLng(L.point(end[0], end[1]));
      if (copyMarker && map.hasLayer(copyMarker)) {
        copyMarker.setLatLng(mousemoveLatlng);
      }
    }
    else {
      mousemoveLatlng = [];
      const latLngs = selectLayer.getLatLngs();
      for (let i = 0; i < latLngs.length; i++) {
        if (Array.isArray(latLngs[i])) {
          mousemoveLatlng.push([]);
          let lls = [];
          for (let j = 0; j < latLngs[i].length; j++) {
            const start = map.latLngToLayerPoint(latLngs[i][j]);
            const end = [start.x + delta[0], start.y + delta[1]];
            const endLatLng = map.layerPointToLatLng(L.point(end[0], end[1]));
            lls.push(endLatLng);
          }
          mousemoveLatlng[i] = lls;
        }
        else {
          const start = map.latLngToLayerPoint(latLngs[i]);
          const end = [start.x + delta[0], start.y + delta[1]];
          const endLatLng = map.layerPointToLatLng(L.point(end[0], end[1]));
          mousemoveLatlng.push(endLatLng);
        }
      }
      if (copyMarker && map.hasLayer(copyMarker)) {
        copyMarker.setLatLngs(mousemoveLatlng);
      }
    }
  }

  const polygon = [
    'Rectangle', 'Polygon',
  ];

  const marker = [
    'Text',
    'Marker',
  ];

  const polyline = [
    'Line',
  ];

  const circleMarker = [
    'CircleMarker',
  ];

  map.on('pm:create', (e) => {
    map.on('contextmenu', disableDraw);

    function disableDraw() {
      map.pm.disableDraw();
      map.off('contextmenu', disableDraw);
    }

    if (!isSegmentation) {
      let { layer, shape } = e;
      console.log('create one', shape, e);
      if (polygon.includes(shape)) {
        shape = 'polygon';
        layer.setStyle({
          color: '#4CAF50',
        });
      }
      if (marker.includes(shape)) {
        shape = 'marker';
      }
      if (polyline.includes(shape)) {
        shape = 'polyline';
        layer
          .on('mouseover', function(e) {
            e.sourceTarget.setStyle({
              weight: 8,
              opacity: 0.6,
              color: '#f6634f',
            });
          })
          .on('mouseout', function(e) {
            e.sourceTarget.setStyle({
              weight: 3,
              opacity: 1,
              color: '#3388ff',
            });
          });
      }
      if (circleMarker.includes(shape)) {
        shape = 'circleMarker';
      }
      layer.shape = shape;
      layer.isSegmentation = isSegmentation;
      bindContextMenu(shape, layer);
      layer.on('click', e => {
        L.DomEvent.stopPropagation(e);
        selectLayer = e.sourceTarget;
      });
      layer.uuid = uuid.v4();
      layer.bindPopup(`<sapn>${popup(layer)}</sapn>`);
      drawLayers.push(layer);
    }
    else {
      segmentationLine(layer);
    }
  });

  function popup(layer) {
    const res = {};
    res['编号'] = layer.uuid;
    if (layer.shape === 'polygon') {
      res['面积'] = turf.round(turf.area(layer.toGeoJSON()), 2) + '㎡';
    }
    if (layer.shape === 'polyline') {
      res['长度'] = turf.round(turf.length(layer.toGeoJSON(), { units: 'kilometers' }), 3) + '㎞';
    }
    if (layer.shape === 'marker' || layer.shape === 'circleMarker') {
      const latLng = turf.truncate(layer.toGeoJSON());
      res['经度'] = latLng.geometry.coordinates[0];
      res['纬度'] = latLng.geometry.coordinates[1];
    }
    let html = '';
    Object.keys(res)
      .forEach(key => {
        html += `<p>${key}: ${res[key]}</p>`;
      });
    return html;
  }
</script>
</body>
</html>
